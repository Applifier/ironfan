h1. cluster_chef

Chef is a powerful tool for maintaining and describing the software and configurations that let a machine provide its services.

cluster_chef is

* a clean, expressive way to describe how machines and roles are assembled into a working cluster
* Our collection of Industrial-strength, cloud-ready recipes for Hadoop, Cassandra, HBase, Elasticsearch and more
* a set of conventions and helpers that make provisioning cloud machines easier

h2. Walkthrough

Here's a basic 3-node hadoop cluster:

<pre>
    ClusterChef.cluster 'demohadoop' do
      merge!('defaults')
      
      facet 'master' do
        instances           1
        role                "nfs_server"
        role                "hadoop_master"
        role                "hadoop_worker"
        role                "hadoop_initial_bootstrap"
      end

      facet 'worker' do
        instances           2
        role                "nfs_client"
        role                "hadoop_worker"
        server 0 do
	  chef_node_name 'demohadoop_worker_zero'
        end 
      end

      cloud :ec2 do
        image_name          "lucid"
        flavor              "c1.medium"
        availability_zones  ['us-east-1d']
        security_group :logmuncher do
          authorize_group "webnode"
        end
      end
      
    end
</pre>

This defines a *cluster* (group of machines that serve some common purpose) with two *facets*, or unique configurations of machines within the cluster. (For another example, a webserver farm might have a loadbalancer facet, a database facet, and a webnode facet).

In the example above, the master serves out a home directory over NFS, and runs the processes that distribute jobs to hadoop workers. In this small cluster, the master also has workers itself, and a utility role that helps initialize it out of the box.

There are 2 workers; they use the home directory served out by the master, and run the hadoop worker processes. 

Lastly, we define what machines to use for this cluster. Instead of having to look up and type in an image ID, we just say we want the Ubuntu 'Lucid' distribution on a c1.medium machine. Cluster_chef understands that this means we need the 32-bit image in the us-east-1 region, and makes the cloud instance request accordingly. It also creates a 'logmunchers' security group, opening it so all the 'webnode' machines can push their server logs onto the HDFS.

The following commands launch each machine, and once ready, ssh in to install chef and converge all its software.

<pre>
    knife cluster launch demohadoop master --bootstrap
    knife cluster launch demohadoop worker --bootstrap
</pre>

You can also now launch the entire cluster at once with the following

<pre>
   knife cluster launch demohadoop --bootstrap
</pre>

The cluster launch operation is (mostly) idempotent. (There is currently a short time after the completion of a cluster launch where a second cluster launch will create extra nodes that do not belong.)

h2. Philosophy

Some general principles of how we use chef.

* Chef server is *never* the repository of truth -- it only mirrors the truth.
  - a file is tangible and immediate to access
* Specifically, we want truth to live in the git repo, and be enforced by the chef server. There is no truth but git, and chef is its messenger.
  - this means that everything is versioned, documented and exchangeable.
* All major systems, services and significant modifications to the machines in a cluster should be in front of me on the page when I look at its `clusters` file.  I don't want to have to bounce around nine different files to find out which thing installed a redis:server.
* ...you don't want to get too detailed though -- roles exist for a reason, and if cluster files start getting unruly.
* It's nice when machines are in full control of their destiny.
  - initial setup (elastic IP, attaching a drive) is often best enforced externally
  - but machines should be ablt independently assert things like load balancer registration that that might change at any point in the lifetime.
* It's even nicer, though, to have full idempotency from the command line: I can at any time push truth from the git repo to the chef server and know that it will take hold.

---------------------------------------------------------------------------

h2. Getting Started

This assumes you have installed chef, have a working chef server, and have an AWS account. If you can run knife and use the web browser to see your EC2 console, you can start here. If not, see the instructions below.

h3. Setup

Install these gems (you may have several installed already):

<pre>
sudo gem install chef fog highline configliere net-ssh-multi formatador terminal-table gorillib extlib
</pre>

(and maybe right_aws and broham?)

h4. Add cluster_chef to your cookbooks repo

This assumes the same setup as described in the knife quickstart walkthrough, but to keep things convenient we'll use these shortcuts to refer

<pre>
CHEF_REPO_DIR=$HOME/PATH/TO/chef-repo      # has cookbooks/ and site-cookbooks/
DOT_CHEF_DIR=$HOME/PATH/TO/chef-repo/.chef # has your knife.rb, USERNAME.pem etc
</pre>

I recommend adding cluster chef as a git submodule; you can instead clone it elsewhere.

<pre>
cd $CHEF_REPO_DIR
git submodule add git@github.com:infochimps/cluster_chef.git cluster_chef
</pre>

h4. Knife setup

In your <code>$DOT_CHEF_DIR/knife.rb</code>, modify the cookbook path (to include cluster_chef/cookbooks and cluster_chef/site-cookbooks) and to add settings for @cluster_chef_path@ and @keypair_path@. Here's mine:

<pre>
current_dir = File.dirname(__FILE__)
organization  = 'CHEF_ORGANIZATION'
username      = 'CHEF_USERNAME'

# The full path to your cluster_chef installation
cluster_chef_path File.expand_path("#{current_dir}/../cluster_chef")
# The directory holding your cloud keypairs
keypair_path      File.expand_path(current_dir)

log_level                :info
log_location             STDOUT
node_name                username
client_key               "#{keypair_path}/#{username}.pem"
validation_client_name   "#{organization}-validator"
validation_key           "#{keypair_path}/#{organization}-validator.pem"
chef_server_url          "https://api.opscode.com/organizations/#{organization}"
cache_type               'BasicFile'
cache_options( :path => "#{ENV['HOME']}/.chef/checksums" )

cookbook_path            [
  "#{current_dir}/../cookbooks",
  "#{current_dir}/../site-cookbooks",
  "#{cluster_chef_path}/cookbooks",
]

# AWS access credentials
knife[:aws_access_key_id]      = "XXXXXXXXXXX"
knife[:aws_secret_access_key]  = "XXXXXXXXXXXXX"
</pre>

h4. Push to chef server

To send all the cookbooks and role to the chef server, visit your cluster_chef directory and run:

<pre>
cd $CHEF_REPO_DIR
knife cookbook upload --all
for foo in roles/*.rb ; do knife role from file $foo & sleep 1 ; done
</pre>

You should see all the cookbooks defined in cluster_chef/cookbooks (ant, apt, ...) listed among those it uploads.

h4. Cluster chef's Knife plugins

<pre>
mkdir -p $DOT_CHEF_DIR/plugins
ln -s $CHEF_REPO_DIR/cluster_chef/lib/cluster_chef/knife           $DOT_CHEF_DIR/plugins/knife
ln -s $CHEF_REPO_DIR/cluster_chef/lib/cluster_chef/knife/bootstrap $DOT_CHEF_DIR/bootstrap
</pre>

If you type @knife cluster launch@ you should see it found the new scripts:

<pre>
    ** CLUSTER COMMANDS **
    knife cluster launch CLUSTER_NAME [FACET_NAME] (options)
    knife cluster show CLUSTER_NAME [FACET_NAME] (options)
</pre>

h3. Your first cluster

h4. Create a simple demo cluster

Create a directory for your clusters; copy the demosimple cluster and its associated roles from cluster_chef:

<pre>
mkdir -p $CHEF_REPO_DIR/clusters
cp cluster_chef/clusters/{defaults,demosimple}.rb ./clusters/
cp cluster_chef/roles/{big_package,nfs_*,ssh}.rb  ./roles/
for foo in roles/*.rb ; do knife role from file $foo ; done
</pre>

Symlink in the cookbooks you'll need, and upload them to your chef server:

<pre>
mkdir -p $CHEF_REPO_DIR/site-cookbooks
cd $CHEF_REPO_DIR/site-cookbooks
ln -s ../cluster_chef/site-cookbooks/{nfs,big_package,cluster_chef,cluster_service_discovery,firewall,motd} .
knife cookbook upload nfs big_package cluster_chef cluster_service_discovery firewall motd
</pre>

h4. AWS credentials

Make a cloud keypair, a secure key for communication with Amazon AWS cloud. 

# Log in to the "AWS console":http://bit.ly/awsconsole and create a new keypair named @demosimple@. Your browser will download the private key file.
# Move the private key file you just downloaded to your .chef dir, and make it private key unsnoopable, or ssh will complain:

<pre>
mv ~/downloads/demosimple.pem $DOT_CHEF_DIR/demosimple.pem
chmod 600 $DOT_CHEF_DIR/*.pem
</pre>

h3. Cluster chef knife commands

h4. knife cluster launch

Hooray! You're ready to launch a cluster:

<pre>
    knife cluster launch demosimple homebase --bootstrap
</pre>

It will kick off a node and then bootstrap it. You'll see it install a whole bunch of things. Yay.

h2. Extended Installation Notes

h3. Set up Knife on your local machine, and a Chef Server in the cloud

If you already have a working chef installation you can skip this section.

To get started with knife and chef, follow the "Chef Quickstart,":http://wiki.opscode.com/display/chef/Quick+Start We use the hosted chef service and are very happy, but there are instructions on the wiki to set up a chef server too. Stop when you get to "Bootstrap the Ubuntu system" -- cluster chef is going to make that much easier.

h3. Cloud setup

If you can use the normal knife bootstrap commands to launch a machine, you can skip this step.

Steps:

* sign up for an AWS account
* Follow the "Knife with AWS quickstart":http://wiki.opscode.com/display/chef/Launch+Cloud+Instances+with+Knife on the opscode wiki.

Right now cluster chef works well with AWS.  If you're interested in modifying it to work with other cloud providers, "see here":https://github.com/infochimps/cluster_chef/issues/28 or get in touch.

h3. Setup for Knife versions before 0.10

On older versions of chef that don't have a plugin mechanism for new commands, we have to do surgery on the knife itself... we'll just symlink the new commands into chef's lib/chef/knife directory, and symlink the bootstrap templates into chef's lib/chef/knife/bootstrap directory. Set the path to your cluster_chef directory and run the following:

<pre>
    sudo ln -s $CLUSTER_CHEF_DIR/lib/cluster_chef/knife/*.rb            $(dirname `gem which chef`)/chef/knife/
    sudo ln -s $CLUSTER_CHEF_DIR/lib/cluster_chef/knife/bootstrap/*     $(dirname `gem which chef`)/chef/knife/bootstrap/
</pre>

Cluster chef is not currently set up to work as a pluggable gem for chef 0.10.0, but will in the near future. Until that time, you can use the knife commands in your local plugins directory with the following command:

<pre>
    ln -s $CLUSTER_CHEF_DIR/lib/cluster_chef/knife  ~/.chef/plugins/knife
    ln -s $CLUSTER_CHEF_DIR/lib/cluster_chef/knife/bootstrap  ~/.chef/bootstrap
</pre> 

h3. Gotchas

* The initial startup is still finicky, but is at least down to only two passes for hadoop:

<pre>
    for foo in hadoop-0.20-{datanode,namenode,tasktracker,jobtracker,secondarynamenode} ; do sudo service $foo stop ; done
    sudo chef-client
</pre>

* For hbase, still dialing it in but there's also this:  
  
<pre>
    sudo -u hdfs hadoop fs -chown -R hbase:hbase /hadoop/hbase
    sudo chef-client
</pre>

* Once the master runs to completion with all daemons started, remove the hadoop_initial_bootstrap recipe from its run_list. (Note that you may have to edit the runlist on the machine itself depending on how you bootstrapped the node).

* For problems starting NFS server on ubuntu maverick systems, read, understand and then run /tmp/fix_nfs_on_maverick_amis.sh -- See "this thread for more":http://fossplanet.com/f10/[ec2ubuntu]-not-starting-nfs-kernel-daemon-no-support-current-kernel-90948/

h3. Zero-bootstrap, fire and forget cluster launch!

Note: Although you can (probably) still use broham to launch a cluster, cluster chef no longer needs it. ClusterChef is now able to assign node with node names without external assistnace.

* Register for Amazon SimpleDB. (Although you do need a credit card, there's no conceivable way broham will approach the free limit.)
* You'll have to run the following one-time command:

<pre>
    sudo gem install broham configliere right_aws
    ruby -rubygems -e 'require "broham"; Broham.establish_connection :access_key=>"YOUR_ACCESS_KEY", :secret_access_key=>"YOUR_KEY"; Broham.create_domain'
</pre>
  
* Now you should be able to use broham:<pre> broham-register `hostname` </pre>
* To have it assign node names dynamically, se the client.rb script in cluster_chef/config as your /etc/chef/client.rb


h2. Chef Concepts

ClusterChef will help you create a scalable, efficient compute cluster in the cloud. It has recipes for Hadoop, Cassandra, NFS and more -- use as many or as few as you like. For example, you can create and:

* A small 1-5 node cluster for development or just to play around with Hadoop or Cassandra
* A spot-priced, ebs-backed cluster for unattended computing at rock-bottom prices
* A large 30+ machine cluster with multiple EBS volumes per node running Hadoop and Cassandra, with optional NFS for

In chef,

* A *Recipe* gives concrete steps that make a node achieve its desired final configuration. For example, the hadoop_cluster cookbook has a recipe to install the hadoop packages, and another to configure and run the namenode. If the cookbook isn't installed,
* A *Cookbook* holds a collections of related recipes and attributes, and the templates, libraries &c that support them. 
* A *Role* is a collection of related recipes and default attributes that work together. For example, there is a 'hadoop_worker'  
